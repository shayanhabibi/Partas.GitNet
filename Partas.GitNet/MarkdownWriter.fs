module Partas.GitNet.MarkdownWriter

open System
open System.Collections.Frozen
open System.Collections.Generic
open FSharp.Formatting.Markdown
open Fake.Core
open Partas.GitNet
open Partas.GitNet.Markdown
module Render = Renderer.Render
open Render
let makeHeader (scopes: (string * string * Tag option * int) array) = [
    Markdown.span {
    $"""# RELEASE NOTES

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to a flavor of [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
which includes [Scopes and Epochs](#epoch-scoped-semver).

---

"""
    }
    if scopes.Length > 1 then
        Markdown.h4 { "Quick Navigation" }
        Markdown.table {
            Markdown.table.headers {
                Markdown.bold { "Scope" }
                "Current Release"
                "Commit Count"
            }
            yield!
                scopes
                |> Array.toList
                |> List.map (fun (scope,link,tag,count) ->
                    Markdown.table.row {
                        Markdown.directLink link {
                            Markdown.bold { scope }
                        }
                        match tag with
                        | Some { TagUrl = ValueSome url; TagName = name } ->
                            Markdown.directLink url { name }
                        | Some { TagName = name } -> name
                        | None -> "Unreleased"
                        Markdown.span {
                            if count = 0 then
                                "None yet!"
                            else
                                $"{count} commits"
                        }
                    }
                    )
            [
                MarkdownColumnAlignment.AlignLeft
                MarkdownColumnAlignment.AlignCenter
                MarkdownColumnAlignment.AlignCenter
            ]
        }
    
]
let makeFooter = Markdown.span {
    """
---

<details>
<summary>Read more about this SemVer flavor</summary>

### Epoch Scoped SemVer

This flavor adds an optional marketable value called an `EPOCH`.
There is also an optional disambiguating `SCOPE` identifier for delineating tags for packages in a mono repo.

<blockquote>The motivation for this is to prevent resistance to utilising SemVer major bumps
correctly, by allowing a separate marketable identifier which is easily compatible
with the current SemVer spec.</blockquote>


An Epoch/Scope (*Sepoch*) is an OPTIONAL prefix to a typical SemVer.

* A Sepoch MUST BE bounded by `_` underscores `_`.
* The identifiers MUST BE ALPHABETICAL (A-Za-z) identifiers.
* The Epoch SHOULD BE upper case
* The Epoch MUST come before the Scope, if both are present.
* The Scope MUST additionally be bounded by `(` parenthesis `)`.
* The Scope SHOULD BE capitalised/pascal cased.
* A Sepoch CAN BE separated from SemVer by a single white space where this is allowed (ie not allowed in git tags).
* Epoch DOES NOT influence precedence.
* Scope MUST uniquely identify a single components versioning.
* Different scopes CANNOT BE compared for precedence.
* A SemVer without a Scope CAN BE compared to a Scoped SemVer for compatibility. But caution is advised.

> There is no enforcement for ordering EPOCHs in this spec, as it
would be overly restrictive and yield little value since we can delineate and
earlier EPOCH from a later EPOCH by the SemVers.

#### Example

```mermaid
gitGraph
commit tag: "_ALPS_1.2.3"
branch develop
commit id: "add: ..."
commit
checkout main
cherry-pick id: "add: ..." tag: "_ALPS_2.1.3"
checkout develop
commit
commit
checkout main
merge develop tag: "_ALPS_3.4.5"
checkout develop
commit
commit
checkout main
merge develop tag: "_BRAVO_4.0.0" type: HIGHLIGHT
```

*While there are breaking changes between versions 1 to 3, we expect that it is less than
from 3 to 4. We expect the API surface would change more dramatically, or there is some other significant
milestone improvement, in the change from version 3 epoch ALPS to version 4 epoch BRAVO.*

```
_WILDLANDS(Core)_ 4.2.0
_WILDLANDS(Engine)_ 0.5.3
_DELTA(Core)_ 5.0.0
_DELTA(Engine)_ 0.5.3
```

*Cannot be compared to `Core` versions. Both Engine versions are equal, we can identify that
the ecosystems marketed change does not change the Engine packages API*

</details>

<!-- generated by Partas.GitNet -->
"""
}


let private dLink (content: string) link = Markdown.directLink link { content } 
module Commit =
    let writeCommit (runtime: GitNetRuntime) (scope: Scope) (commit: Commit) =
        // TODO - first time commit
        let commitSha =
            runtime.githubUrlFactory
            |> Option.map (
                _.CreateCommit(commit.CommitSha)
                >> dLink (commit.CommitSha.Substring(0, 5) |> (+) "#")
                )
            |> Option.defaultValue(
                commit.CommitSha.Substring(0,5)
                |> Markdown.literal
                )
        let commitMsg =
            // We have pre computed the function in the runtime
            runtime.WriteCommitToMarkdown
                (scope.ScopeName |> ValueOption.toOption)
                commit.Message
        Markdown.para {
            commitMsg
            " by "
            match runtime.githubUrlFactory with
            | Some factory ->
                let link = factory.CreateAuthor(commit.CommitAuthor)
                Markdown.directLink link { "@"; commit.CommitAuthor }
            | None ->
                $"@{commit.CommitAuthor}"
            " with "
            commitSha
        }
module Tag =
    type Error = Error
    let writeTitle (tag: Tag) =
        Markdown.h3 {
            match tag.TagUrl with
            | ValueSome url ->
                dLink tag.TagName url
            | ValueNone ->
                tag.TagName
            match tag.TagDate with
            | ValueSome date ->
                $" - ({date})"
            | _ -> ""
        }
    let writeCommitGroups runtime scope (tag: Tag) =
        let writeGroup (group: KeyValuePair<CommitGroup, Commit list>) =
            let group = group.Key
            [
              Markdown.h group.HeadingLevel {
                  match group.Position with
                  | Some pos ->
                      $"<!-- {pos} --> "
                  | _ -> ""
                  group.Title
              }
              match group.Prelude with
              | Some prelude ->
                  yield!
                      Markdown.Parse prelude
                      |> _.Paragraphs
              | _ -> ()
            ]
        tag.Commits
        |> Seq.sortBy _.Key.Position
        |> Seq.map(fun group ->
            let title = writeGroup group
            let unorderedList content = MarkdownParagraph.ListBlock(MarkdownListKind.Unordered, content, None)
            let commits =
                group.Value
                |> List.map (Commit.writeCommit runtime scope >> List.singleton)
                |> unorderedList

            [
                yield! title
                if group.Key.CountOnly
                then
                    Markdown.para {
                        $"Number of commits: {group.Value.Length}"
                    }
                else commits
                match group.Key.Postfix with
                | Some postfix ->
                    yield!
                        Markdown.Parse postfix
                        |> _.Paragraphs
                | _ -> ()
            ]
            )
        |> Seq.collect id
        |> Seq.toList
    
    let writeTag runtime (scope: Scope) (tag: Tag) =
        let commitGroups = writeCommitGroups runtime scope tag
        if commitGroups |> List.isEmpty
        then commitGroups
        else
        [
            writeTitle tag
            yield! commitGroups
        ]
module Scope =
    type Error =
        | NoScope
    let writeTitle scope =
        match scope.ScopeName with
        | ValueSome scopeName ->
            Markdown.h1 { scopeName }
            |> Ok
        | _ ->
            Error Error.NoScope
    let writeUnreleased runtime scope =
        let heading =
            Markdown.h3 {
                match scope.ScopeUnreleasedUrl with
                | ValueSome url ->
                    dLink "UNRELEASED" url
                | ValueNone ->
                    "UNRELEASED"
            }
        [
            heading
            scope.ScopeUnreleased
            |> List.map (Commit.writeCommit runtime scope)
            |> List.map List.singleton
            |> fun content -> MarkdownParagraph.ListBlock(MarkdownListKind.Unordered, content, None)
        ]
    let writeTags runtime (scope: Scope) =
        scope.ScopeTags
        |> List.map (Tag.writeTag runtime scope)
        |> List.collect id

    let writeScope runtime scope =
        match writeTitle scope with
        | Ok title when scope.ScopeCommitCount = 0 ->
            [
                title
                Markdown.para { "No commits at this time." }
            ] |> Some
        | Ok title ->
            [
                title
                yield! writeUnreleased runtime scope
                yield! writeTags runtime scope
                Markdown.span {
                    "<div align=\"right\"><a href=\"#quick-navigation\">(back to top)</a></div>"
                    br
                }
                Markdown.ruler
            ]
            |> Some
        | Error _ -> None

type WriteResult = {
    ScopeBumps: FrozenDictionary<string, BumpResult>
    Document: MarkdownDocument
}

let writeRendering runtime renderResult =
    let renderResult = {
        renderResult with
            Scopes =
                renderResult.Scopes
                |> Array.sortBy (function
                    | { ScopeName = ValueSome name; ScopeCommitCount = n } when n > 0 -> name
                    | { ScopeName = ValueSome name } -> $"ZZZZ{name}"
                    | scope -> scope.ScopeName |> ValueOption.defaultValue null
                    )
    }
    renderResult.Scopes
    |> Seq.choose (Scope.writeScope runtime)
    |> Seq.collect id
    |> Seq.toList
    |> fun paras ->
        let paras =
            [
                yield! makeHeader (
                    renderResult.Scopes
                    |> Array.filter _.ScopeName.IsSome
                    |> Array.map (fun scope ->
                        let makeLinkUrl =
                            _.ScopeName.Value
                            >> String.filter
                                (function ' ' -> true | c -> Char.IsAsciiLetter c)
                            >> _.Replace(' ', '-')
                            >> String.toLower
                            >> sprintf "#%s"                            
                        scope.ScopeName.Value,
                        makeLinkUrl scope,
                        scope.ScopeTags |> List.tryHead,
                        scope.ScopeCommitCount
                        )
                    )
                Markdown.ruler
                yield! paras
                makeFooter
            ]
        MarkdownDocument(paras, dict [])
    |> fun doc ->
        {
            Document = doc
            ScopeBumps = renderResult.Bumps
        }
