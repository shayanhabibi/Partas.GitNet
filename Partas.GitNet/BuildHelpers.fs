[<AutoOpen>]
module Partas.GitNet.BuildHelpers

// During the build process, we are abstracting away version control.
// However, we must keep in mind that a mono repo where packages reference
// each other require knowledge of the other projects versions for their
// nuget referencing.
// For this reason, we need build helpers which will version the project
// files directly for the build process. These are not necessary to commit.

open System.Collections.Generic
open System.Xml.Linq
open Fake.IO
open Fake.DotNet
open System.Xml.XPath
open LibGit2Sharp.FSharp
open Partas.GitNet.RepoCracker
open Partas.Tools.SepochSemver

/// <summary>
/// Versions the project at the given path with the given version, and saves
/// the project. Returns a reversion function that removes the changes.
/// </summary>
/// <param name="projectPath">Path to .fsproj</param>
/// <param name="versionString">Semver string</param>
/// <returns>Revert function to run after the build processes</returns>
let private versionProject (projectPath: string) (versionString: string) =
    let proj = MSBuild.loadProject projectPath
    let originalContent = File.readAsString projectPath
    let revert = fun () -> File.writeString false projectPath originalContent
    let propertyGroupMaybe =
        proj.Document
            .XPathSelectElement("//PropertyGroup")
        |> ValueOption.ofObj
    let versionMaybe =
        proj.Document
            .XPathSelectElement("//PropertyGroup/Version")
        |> ValueOption.ofObj
    let packageVersionMaybe =
        proj.Document
            .XPathSelectElement("//PropertyGroup/PackageVersion")
        |> ValueOption.ofObj
    let makeElement: string -> _ = XElement
    let makeElementWithValue value =
        makeElement
        >> fun el ->
            el.Value <- value
            el
    let makeComment: string -> _ = XComment
    let versionComment = "PackageVersion & Version is AutoGenerated. Do not modify." |> makeComment
    let inline makePackageVersion () =
        "PackageVersion"
        |> makeElementWithValue versionString
    let inline makeVersion () =
        "Version"
        |> makeElementWithValue versionString
    let save () = proj.Save(projectPath)
    match propertyGroupMaybe, versionMaybe, packageVersionMaybe with
    | ValueSome propertyGroup, ValueNone, ValueNone ->
        let version,packageVersion = makeVersion(), makePackageVersion()
        propertyGroup.Add(version,packageVersion)
        version.AddBeforeSelf(versionComment)
        |> save
        revert
    | ValueSome _, ValueSome version, ValueSome packageVersion ->
        let previousVersion,previousPackageVersion = version.Value, packageVersion.Value
        version.Value <- versionString
        packageVersion.Value <- versionString
        save ()
        revert
    | ValueSome propertyGroup, ValueSome version, _ ->
        let previousVersion = version.Value
        version.Value <- versionString
        let packageVersion = makePackageVersion()
        propertyGroup.Add(packageVersion)
        packageVersion.AddBeforeSelf(versionComment)
        |> save
        revert
    | ValueSome propertyGroup, _, ValueSome packageVersion ->
        let previousPackageVersion = packageVersion.Value
        packageVersion.Value <- versionString
        let version = makeVersion()
        propertyGroup.Add(version)
        version.AddBeforeSelf(versionComment)
        |> save
        revert
    | ValueNone, _, _ ->
        let projectMaybe =
            proj.XPathSelectElement("//Project[@Sdk]")
            |> Option.ofObj
        match projectMaybe with
        | Some element ->
            let propertyGroup = makeElement "PropertyGroup"
            propertyGroup.Add(makeVersion(), makePackageVersion())
            element.Add(propertyGroup)
            proj.Save(projectPath)
            revert
        | None ->
            failwith "Cannot version a project without a Project node"

let private getProjectsForMapping (mapping: IDictionary<string, SepochSemver>) (runtime: GitNetRuntime) =
        runtime.CrackRepo
        |> Seq.choose(function
            | CrackedProject.FSharp ({
                  GitNetOptions = {
                  Scope = Some scope
                }
            } as proj)when mapping.ContainsKey(scope) ->
                Some proj
            | _ -> None
            )
        |> Seq.map(
            fun proj ->
                let semver = mapping.Item(proj.GitNetOptions.Scope.Value)
                proj,semver
            )

type GitNetRuntime with
    member this.VersionProject(project: FSharpCrackedProject, version: Semver.SemVersion, ?stageFile: bool, ?cacheDisposal: bool) =
        let projectPath = Path.combine this.rootDir project.ProjectFileName
        let stageFile = defaultArg stageFile false
        let cacheDisposal = defaultArg cacheDisposal true
        versionProject projectPath (version.ToString())
        |> if cacheDisposal
            then this.Disposals.Add
            else ignore
        if stageFile then
            try
            this.repo
            |> Repository.index
            |> Index.addFile project.ProjectFileName
            this.StatVersionFile projectPath
            with e ->
                e
                |> printfn "Filed to stage %s:\n%A" projectPath
        else this.StatVersionFile projectPath
    /// <summary>
    /// Uses the bump dictionary
    /// to write the versions to the
    /// files to prepare them for packing.
    /// </summary>
    member this.VersionProjects(mapping: IDictionary<string, SepochSemver>, ?stageFile: bool, ?cacheDisposal: bool) =
        this
        |> getProjectsForMapping mapping
        |> Seq.iter(
            fun (proj, semver) ->
                this.VersionProject(proj, semver.SemVer, ?cacheDisposal = cacheDisposal, ?stageFile = stageFile)
            )
    member this.RevertVersionProjects() =
            let runDisposal func =
                try
                func()
                with e ->
                    e
                    |> printfn "Error while disposing of cached disposals:\n%A"
            this.Disposals |> Seq.iter runDisposal
    member this.StageVersionProjects(mapping: IDictionary<string, SepochSemver>) =
        let index =
            this.repo
            |> Repository.index
        let initial = index.Count
        this |> getProjectsForMapping mapping
        |> Seq.iter(
            fun (proj,semver) ->
                this.VersionProject(proj, semver.SemVer, false)
                index |> Index.addFile (System.IO.Path.GetRelativePath(this.rootDir,proj.ProjectFileName))
            )
        index |> Index.write
        index.Count - initial
        |> printfn "Staged %i files (Versioned project files)."
    
