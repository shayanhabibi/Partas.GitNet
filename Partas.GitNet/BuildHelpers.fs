module Partas.GitNet.BuildHelpers

// During the build process, we are abstracting away version control.
// However, we must keep in mind that a mono repo where packages reference
// each other require knowledge of the other projects versions for their
// nuget referencing.
// For this reason, we need build helpers which will version the project
// files directly for the build process. These are not necessary to commit.

open System
open System.Collections.Generic
open System.Xml
open System.Xml.Linq
open Fake.IO
open Fake.DotNet
open System.Xml.XPath
open LibGit2Sharp.FSharp
open Partas.GitNet.RepoCracker
open Partas.Tools.SepochSemver

/// <summary>
/// Versions the project at the given path with the given version, and saves
/// the project. Returns a reversion function that removes the changes.
/// </summary>
/// <param name="projectPath">Path to .fsproj</param>
/// <param name="versionString">Semver string</param>
/// <returns>Revert function to run after the build processes</returns>
let versionProject (projectPath: string) (versionString: string) =
    let proj = MSBuild.loadProject projectPath
    let originalContent = File.readAsString projectPath
    let revert = fun () -> File.writeString false projectPath originalContent
    let propertyGroupMaybe =
        proj.Document
            .XPathSelectElement("//PropertyGroup")
        |> ValueOption.ofObj
    let versionMaybe =
        proj.Document
            .XPathSelectElement("//PropertyGroup/Version")
        |> ValueOption.ofObj
    let packageVersionMaybe =
        proj.Document
            .XPathSelectElement("//PropertyGroup/PackageVersion")
        |> ValueOption.ofObj
    let makeElement: string -> _ = XElement
    let makeElementWithValue value =
        makeElement
        >> fun el ->
            el.Value <- value
            el
    let makeComment: string -> _ = XComment
    let versionComment = "PackageVersion & Version is AutoGenerated. Do not modify." |> makeComment
    let inline makePackageVersion () =
        "PackageVersion"
        |> makeElementWithValue versionString
    let inline makeVersion () =
        "Version"
        |> makeElementWithValue versionString
    let save () = proj.Save(projectPath)
    match propertyGroupMaybe, versionMaybe, packageVersionMaybe with
    | ValueSome propertyGroup, ValueNone, ValueNone ->
        let version,packageVersion = makeVersion(), makePackageVersion()
        propertyGroup.Add(version,packageVersion)
        version.AddBeforeSelf(versionComment)
        |> save
        revert
    | ValueSome _, ValueSome version, ValueSome packageVersion ->
        let previousVersion,previousPackageVersion = version.Value, packageVersion.Value
        version.Value <- versionString
        packageVersion.Value <- versionString
        save ()
        revert
    | ValueSome propertyGroup, ValueSome version, _ ->
        let previousVersion = version.Value
        version.Value <- versionString
        let packageVersion = makePackageVersion()
        propertyGroup.Add(packageVersion)
        packageVersion.AddBeforeSelf(versionComment)
        |> save
        revert
    | ValueSome propertyGroup, _, ValueSome packageVersion ->
        let previousPackageVersion = packageVersion.Value
        packageVersion.Value <- versionString
        let version = makeVersion()
        propertyGroup.Add(version)
        version.AddBeforeSelf(versionComment)
        |> save
        revert
    | ValueNone, _, _ ->
        let projectMaybe =
            proj.XPathSelectElement("//Project[@Sdk]")
            |> Option.ofObj
        match projectMaybe with
        | Some element ->
            let propertyGroup = makeElement "PropertyGroup"
            propertyGroup.Add(makeVersion(), makePackageVersion())
            element.Add(propertyGroup)
            proj.Save(projectPath)
            revert
        | None ->
            failwith "Cannot version a project without a Project node"

let getProjectsForMapping (mapping: IDictionary<string, SepochSemver>) (runtime: GitNetRuntime) =
        runtime.CrackRepo
        |> Seq.choose(function
            | CrackedProject.FSharp ({
                  GitNetOptions = {
                  Scope = Some scope
                }
            } as proj)when mapping.ContainsKey(scope) ->
                Some proj
            | _ -> None
            )
        |> Seq.map(
            fun proj ->
                let semver = mapping.Item(proj.GitNetOptions.Scope.Value)
                proj,semver
            )

type GitNetRuntime with
    member this.VersionProject(project: FSharpCrackedProject, version: Semver.SemVersion, ?stageFile: bool, ?cacheDisposal: bool) =
        let projectPath = Path.combine this.rootDir project.ProjectFileName
        let stageFile = defaultArg stageFile false
        let cacheDisposal = defaultArg cacheDisposal true
        versionProject projectPath (version.ToString())
        |> if cacheDisposal
            then this.Disposals.Add
            else ignore
        if stageFile then
            try
            this.repo
            |> Repository.index
            |> Index.addFile projectPath
            with e ->
                e
                |> printfn "Filed to stage %s:\n%A" projectPath
    /// <summary>
    /// Uses the bump dictionary
    /// to write the versions to the
    /// files to prepare them for packing.
    /// </summary>
    member this.VersionProjects(mapping: IDictionary<string, SepochSemver>, ?stageFile: bool, ?cacheDisposal: bool) =
        this
        |> getProjectsForMapping mapping
        |> Seq.iter(
            fun (proj, semver) ->
                this.VersionProject(proj, semver.SemVer, ?cacheDisposal = cacheDisposal, ?stageFile = stageFile)
            )
    member this.RevertVersionProjects() =
            let runDisposal func =
                try
                func()
                with e ->
                    e
                    |> printfn "Error while disposing of cached disposals:\n%A"
            this.Disposals |> Seq.iter runDisposal
    member this.StageVersionProjects(mapping: IDictionary<string, SepochSemver>) =
        let index =
            this.repo
            |> Repository.index
        let initial = index.Count
        this |> getProjectsForMapping mapping
        |> Seq.iter(
            fun (proj,semver) ->
                this.VersionProject(proj, semver.SemVer, false)
                index |> Index.addFile proj.ProjectFileName
            )
        index |> Index.write
        index.Count - initial
        |> printfn "Staged %i files (Versioned project files)."
    
